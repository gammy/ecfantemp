#!/usr/bin/env bash
# This is a fan / temperature control helper for ectool.
# By gammy, anno 2024. To reach me, try https://github.com/gammy
#
# If you don't need ectool to control your fan, this probably isn't for you.
# I wrote this to control the fan on my AMD Framework 13 laptop.
# G**gle Chromebewks also use it, which is, I suppose, why ectool exists.
#
# This was born out of pure frustration and was hacked together rather hastily.
# Don't judge me, Judge the ectool authors for that clusterf*ck.
#
# See `assert_deps` below for dependencies (ectool is required!)
#
# Copyright (C) 2024 Kristian Gunstone
# Use of this source code is governed by the Simplified BSD License:
# https://opensource.org/license/bsd-2-clause

DEFAULT_MAX_RPM=7000 # Seems to be the maximum on my Framework 13
ECF_VERSION=0.8.1

# Set a default parameters if not specified and not set in the shell
[ -n "$ECF_MAX_RPM" ] && ECF_RPM_NAG_OFF=stfu
[ -z "$ECF_MAX_RPM" ] && ECF_MAX_RPM=$DEFAULT_MAX_RPM
[ -z "$ECF_TEMP_UNIT" ] && ECF_TEMP_UNIT=C
[ -z "$ECF_WATCH_INTERVAL" ] && ECF_WATCH_INTERVAL=2

assert_deps() {
    local dep
    for dep in ectool bash column sudo bc mktemp seq; do
        if ! which $dep > /dev/null 2>&1; then
            local deps_missing=1
            echo "I need '$dep' to work." >&2
        fi
    done

    [ -n "$deps_missing" ] && exit 1
}

usage() {
    local me=`basename $0`
    cat << EOF
$me v$ECF_VERSION
An ectool wrapper to simplify fan / temperature reading and configuration.

It displays and accepts temperature parameters in Celsius, Fahrenheit or Kelvin
and doesn't force you to set *all* the bloody thermal parameters every time
you want to change a single setting. Unlike 'ectool' that was clearly written
to be used solely by robots, this script tries to make its use more appropriate
for human beings.

A temperature parameter that ends with K, C or F will be auto-converted.
The 'show', 'watch' and 'info' options also accept a unit as an argument.
The environment variable ECF_TEMP_UNIT can be overridden to change the
default unit; it's currently set to $ECF_TEMP_UNIT.

When run without options, 'show \$ECF_TEMP_UNIT' is issued.
The following environment variables can also be set to alter behaviour:
ECF_MAX_RPM, ECF_RPM_NAG_OFF, ECF_TEMP_UNIT, ECF_SHOW_CALLS and ECF_WATCH_RATE.

Usage:
  $me <watch|show|info|set> [options] [option] [..]

Options:
  show    Show the current sensor temperatures, fan speed(s) and common info.
  watch   Same as 'show' but runs in a loop a la 'watch'.
  info    Show the thermal parameters/values for warn, high, halt, off and max.
  set     Set fan or sensor parameters. The syntax is one of:
          fan    <speed in RPM or off/auto/max> [fan ID]
          sensor <sensor number> <warn|high|halt|off|max> <degrees[unit]>

Examples:
    $me show
    $me set fan 5000   # set fan 0 to 5000 RPM
    $me set fan auto 2 # set fan 2 to automatic control
    $me set sensor 1 warn 90C
    $me watch K
    $me info C

When the fan speed is set to 'auto', the firmware sets the fan duty cycle
with the following formula clamped between 0 and 100:
  100 * (Temperature - Fan Off) / (Fan Max - Fan Off)
Which seems like a pretty stupid formula if you ask me, but it is what it is.
The parameters in this formula can be viewed with '$me info'.
You won't learn which sensor the automatic control feature uses though. Nice.

EOF
}

sep_val_unit() {
    local input=$1
    local last=${input: -1}
    local output=${input::-1}
    local unit

    case $last in
        c|C) unit=C;;
        f|F) unit=F;;
        k|K) unit=K;;
        *) unit="$ECF_TEMP_UNIT"; output=$input;;
    esac
    echo "$output $unit"
}

unit_to_kelvin() {
    local val=$1
    local unit=$2
    local kelvin=$val # Assume input is kelvin

    case $unit in
        c|C) val=`echo "273.15 + $val"              | bc -l`;;
        f|F) val=`echo "273.15 + ($val - 32) * 5/9" | bc -l`;;
        k|K) true ;;
        *) true ;;
    esac

    # ectool doesn't like decimals, so we chop them off completely.
    local dec_places=0 # Limit output to 'scale' n decimal places
    echo "scale=$dec_places; $val*10/10" | bc -l
}

kelvin_to_unit() {
    local kelvin=$1
    local unit=$2

    case $unit in
        c|C) kelvin=`echo " $kelvin - 273.15"             | bc -l`;;
        f|F) kelvin=`echo "($kelvin - 273.15) * 9/5 + 32" | bc -l`;;
        k|K) ;;
        *) ;;
    esac

    local dec_places=1 # Limit output to n decimal places
    echo "scale=$dec_places; $kelvin*10/10" | bc -l
}

compute_ratio() {
    local fan_min=$1
    local fan_max=$2
    if [ "$fan_min" = "$fan_max" ]; then
        echo "None(min=max)"
    else
        local val=` echo "(($fan_max - $fan_min) / 1000) * 100" | bc -l`
        [ "${val:0:1}" = "." ] && val="0$val"
        echo ${val:0:3}%
    fi
}

thermal_set() {
    local sensor=$1
    local item=$2

    local val_unit=(`sep_val_unit $3`)
    local val=${val_unit[0]}
    local unit=${val_unit[1]}
    local val_k=(`unit_to_kelvin "$val" "$unit"`)
    local index

    case "$item" in
        warn) index=1 ;;
        high) index=2 ;;
        halt)
            echo "Careful: if you mess up the temperature for halt, \
your computer might instantly shut off";
            echo "PRESS ^C TO CANCEL OR RETURN TO CONTINUE"
            read
            index=3 ;;
        off) index=4 ;;
        max) index=5 ;;
        *)
            usage
            echo "Invalid item: '$item'"
            exit 1
            ;;
    esac

    echo "Old:"
    thermal_conv $unit

    local cols=(`sudo ectool thermalget | head -n-1 | tail -n+2 \
        | grep "^\s*${sensor}\s"`)
    local cols_old=(${cols[@]})
    local oldval=${cols[$index]}

    if [ "$oldval" = "$val_k" ]; then
        echo "$item on sensor $sensor is already set to $val_k K ($val $unit)"
        return
    fi

    cols[$index]=$val_k

    local k_warn=${cols[1]}
    local k_high=${cols[2]}
    local k_halt=${cols[3]}
    local k_fan_off=${cols[4]}
    local k_fan_max=${cols[5]}

    # UGHhhhhhh you need to pass all the parameters! Come ON!
    # Usage: thermalset sensor warn [high [shutdown [fan_off [fan_max]]]]
    echo
    echo "Changing $item on sensor $sensor from $oldval K to $val_k K ($val $unit)"
    [ -n "$ECF_SHOW_CALL" ] && \
        echo "> ectool thermalset $sensor $k_warn $k_high $k_halt $k_fan_off $k_fan_max"
    sudo ectool thermalset $sensor $k_warn $k_high $k_halt $k_fan_off $k_fan_max

    echo
    echo "New:"
    thermal_conv $unit
}

thermal_conv() {
    local unit=$1
    [ -z "$unit" ] && unit=$ECF_TEMP_UNIT

    local thermalinfo=`mktemp`
    local thermalinfoc=`mktemp`

    [ -n "$ECF_SHOW_CALL" ] && echo "> ectool thermalget"
    sudo ectool thermalget > "$thermalinfo"

    cat "$thermalinfo" | head -n-1 | tail -n+2 | while read line; do
        cols=($line)
        sensor=${cols[0]}
        k_warn=${cols[1]}
        k_high=${cols[2]}
        k_halt=${cols[3]}
        k_fan_off=${cols[4]}
        k_fan_max=${cols[5]}
        name=${cols[6]}

        u_warn=`kelvin_to_unit "$k_warn" "$unit"`
        u_high=`kelvin_to_unit "$k_high" "$unit"`
        u_halt=`kelvin_to_unit "$k_halt" "$unit"`
        u_fan_off=`kelvin_to_unit "$k_fan_off" "$unit"`
        u_fan_max=`kelvin_to_unit "$k_fan_max" "$unit"`

        echo "$sensor ($name),\
${u_warn}°${unit} (${k_warn}K),\
${u_high}°${unit} (${k_high}K),\
${u_halt}°${unit} (${k_halt}K) ,\
${u_fan_off}°${unit} (${k_fan_off}K),\
${u_fan_max}°${unit} (${k_fan_max}K)" >> "$thermalinfoc"

    done

    rm "$thermalinfo"

    column -t -s ',' \
           -C name="Sensor" \
           -C name="Warn" \
           -C name="High" \
           -C name="Halt" \
           -C name="Fan Off(<=)" \
           -C name="Fan Max(>=)" \
           "$thermalinfoc"

    rm "$thermalinfoc"
}

temps_all()
{
    local unit=$1
    [ -z "$unit" ] && unit=$ECF_TEMP_UNIT

    [ -n "$ECF_SHOW_CALL" ] && echo "> ectool temps all"
    local tempinfo=`mktemp`
    local index=0

    # Parse the mangled inconsistent mess that ectool outputs
    sudo ectool temps all | tail -n+2 | sed 's/ and / /' | while read line; do
        cols=($line)
          name=${cols[0]}
        temp_k=${cols[1]}
        # temp_u=${cols[4]} # Omg 'ectool temps' converts to C for us! Discard.
        temp_u=`kelvin_to_unit "$temp_k" "$unit"`
        # ratio=${cols[6]} # ectool prints ratio as integers -____- Discard.
        local  off_k=${cols[7]//[!0-9]}
        local  max_k=${cols[9]//[!0-9]}
        local ratio=`compute_ratio "$off_k" "$max_k"`
        local off_u=`kelvin_to_unit "$off_k" "$unit"`
        local max_u=`kelvin_to_unit "$max_k" "$unit"`
        echo "$index ($name),\
$temp_u°$unit (${temp_k}K),$ratio,\
$off_u°$unit (${off_k}K),\
$max_u°$unit (${max_k}K)" >> $tempinfo
        let index=$index+1 # 'ectool temps' neglects to print index, so -__-
    done

    column -t -s ',' \
           -C name="Sensor" \
           -C name="Temperature" \
           -C name="Off-Max Ratio" \
           -C name="Fan Off(<=)" \
           -C name="Fan Max(>=)" \
           "$tempinfo"

    rm $tempinfo

    echo

    [ -n "$ECF_SHOW_CALL" ] && echo "> ectool pwmgetfanrpm all"
    sudo ectool pwmgetfanrpm all | while read line; do
        local cols=($line)
        local fan_num=${cols[1]}
        local fan_rpm=${cols[3]}
        local speed_pct=`echo "($fan_rpm / $ECF_MAX_RPM) * 100.0" | bc -l`
        [ "${speed_pct:0:1}" = "." ] && speed_pct="${speed_pct}0"
        local speed_pct=${speed_pct:0:4}
        local speed_sub=${speed_pct/.*/}
        let local dec_div="${speed_pct/.*/}/10"
        let local dec_rem="10-$dec_div"
        local bar_full=`seq -s '=' 0 $dec_div | tr -d '[:digit:]'`
        local bar_empty=`seq -s ' ' 0 $dec_rem | tr -d '[:digit:]'`
        echo "Fan $fan_num [$bar_full|$bar_empty] $fan_rpm RPM ($speed_pct% duty) "
    done
    echo
}

#############################################################################

assert_deps

if [ $# -eq 0 ]; then
    echo "Issuing 'show' command, see -h for more." >&2
    echo
    cmd=show
else
    cmd=$1
    shift
fi

if [ "$cmd" = "show" -o "$cmd" = "watch" -o "$cmd" = "set" ]; then
    if [ -z "$ECF_RPM_NAG_OFF" ]; then
        cat << EOF
Warn: The maximum fan RPM used to calculate the duty cycle is hardcoded to \
$ECF_MAX_RPM.
      Silence this warning by setting ECF_MAX_RPM or ECF_RPM_NAG_OFF.

EOF
    fi
fi

# I mean, why use an exhaustion loop and a case when you can do this...!

if [ "$cmd" = "set" ]; then
     opt=$1
     if [ "$opt" = "fan" ]; then
         val=$2
         fan_id="$3"
         if [ -z "$val" ]; then
             usage
             exit 1
         fi
         if [ -z "$fan_id" ]; then
            echo "No fan specified, using fan 0"
            fan_id=0
         fi
         if [ "$val" = "auto" ]
         then
             [ -n "$ECF_SHOW_CALL" ] && echo "> autofanctrl $fan_id"
             sudo ectool autofanctrl $fan_id
         else
             [ "$val" = "off" ] && val=0
             [ "$val" = "max" ] && val=$ECF_MAX_RPM
             fanrpm=${val//[!0-9]/}
             if [ -n "$fanrpm" ]; then
                 [ -n "$ECF_SHOW_CALL" ] && echo "> ectool pwmsetfanrpm $fan_id $fanrpm"
                 sudo ectool pwmsetfanrpm $fan_id $fanrpm
             else
                usage
                exit 1
             fi
         fi
     elif [ "$opt" = "sensor" ]; then
         if [ $# -ne 4 ]; then
             usage
             exit 1
         fi
         thermal_set $2 $3 $4
     else
        usage
        exit 1
     fi
elif [ "$cmd" = "show" ]; then
    temps_all $1
elif [ "$cmd" = "watch" ]; then
    busy=1
    while [ -n "$busy" ]; do
        buffer=`clear; temps_all $1` # Do some buffering; reduces flicker a bit
        echo -e "$buffer"
        read -t$ECF_WATCH_INTERVAL -n1 key
        [ "$key" = "q" ] && unset busy
    done
elif [ "$cmd" = "info" ]; then
    thermal_conv $1
else
     usage
     exit 1
fi
